<?xml version="1.0"?>
<launch>

    <arg name="log_output" default="screen"/>
    <arg name="bluerov_node_device" default="udp:localhost:14550"/>
    <arg name="joy_dev" default="/dev/input/js0"/>
    <arg name="joy_mode" default="Body"/><!-- Joystick steering frame Body or Global -->

    <arg name="UseWaterLinkedDVL" default="true"/>
    <arg name="UseTeledyneDVL" default="false"/>
    <arg name="UseRigidBody" default="false"/>
    <arg name="UseEKF" default="true"/>
    <arg name="UseOrbEKF" default="true"/>

    <!-- start bluerov2 node -->
    <node respawn="true" pkg="bluerov" type="node" name="node" output="$(arg log_output)">
        <param name="device" value="$(arg bluerov_node_device)"/>
        <param name="joy_mode" value="$(arg joy_mode)"/>
    </node>


 <group if="$(arg UseTeledyneDVL)">
	<include file="$(find bluerov)/launch/tf_teledyne.launch" />
  <!-- start Teledyne DVL -->
  <arg name="port" default="/dev/ttyUSB0" doc="serial port"/>
  <arg name="baudrate" default="9600" doc="serial baud rate"/>
  <arg name="frame" default="dvl" doc="frame ID"/>
  <arg name="timeout" default="1.0" doc="serial read timeout in seconds"/>
  <node name="teledyne_explorer" pkg="teledyne_explorer" type="teledyne_explorer" output="$(arg log_output)" respawn="true" respawn_delay="5"> 
    <param name="port" value="$(arg port)" type="str"/>
    <param name="baudrate" value="$(arg baudrate)" type="int"/>
    <param name="frame" value="$(arg frame)" type="str"/>
    <param name="timeout" value="$(arg timeout)" type="double"/>
  </node>
  </group>


 <group if="$(arg UseWaterLinkedDVL)">
  <!-- start WaterLinked DVL -->
	<!-- <include file="$(find bluerov)/launch/tf_waterlinked.launch" /> -->
  <node pkg="waterlinked_a50_ros_driver" type="publisher.py" name="a50_DVL" clear_params="true" output="$(arg log_output)">
  </node>
 </group>

  <!-- Convert data from blueROV for localisation node: TODO: Move much of this to drivers instead 
  <node pkg="bluerov" type="SensorDataConverter.py" name="SensorDataConverter" clear_params="true" output="$(arg log_output)">
  </node> -->



   <!-- State estimation based on raw data, no filter: publishes on /odometry/raw -->
<group if="$(arg UseRigidBody)">
   <node pkg="bluerov" type="rigidBody.py" name="rigidBody" clear_params="true" output="$(arg log_output)" />
 </group>

<!-- Pilot converter, to be integrated later -->
	<!-- <node pkg="bluerov" type="pilot_converter.py" name="DVL_converter" output="$(arg log_output)"/>  -->


<!-- State estimation based EKF: publishes on /odometry/filtered -->
<group if="$(arg UseEKF)">
	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_se" clear_params="true" output="$(arg log_output)">
    	<rosparam command="load" file="$(find bluerov)/params/bluerov2.yaml" />
  </node>
</group>

<group if="$(arg UseOrbEKF)">
	<node pkg="robot_localization" type="ekf_localization_node" name="ekf_orb_se" clear_params="true" output="$(arg log_output)">
    	<rosparam command="load" file="$(find bluerov)/params/orb_ekf.yaml" />
    <remap from="odometry/filtered" to="odometry/orb/filtered"/>
  </node>
</group>

<!-- GPIO  controllers -->
  <node pkg="bluerov" type="GPIO_PWM_controller.py" name="gpio_pwm_controller" output="$(arg log_output)">
  </node>


  <!--node respawn="true" name="master_discovery" pkg="fkie_master_discovery" type="master_discovery" args=" _mcast_group:=224.0.0.1">
  </node-->
  <!--node respawn="true" name="master_sync" pkg="fkie_master_sync" type="master_sync" >
  </node-->
</launch>
